#!/bin/bash
CLIDE_VERSION="0.1.0"

IMAGE_PREFIX="clide"

# Get the absolute path of the directory where this script lives
PDE_DIR="$(cd "$(dirname "${BASH_SOURCE}")" && pwd)"
TARGET_DIR="$(pwd)"
export APP_SOURCE="$(cd "$TARGET_DIR" && pwd)"

BASE_IMAGE_FILE="$APP_SOURCE/.base-image"

if [ -f "$BASE_IMAGE_FILE" ]; then
	export BASE_IMAGE=$(cat "$BASE_IMAGE_FILE" | xargs)
else
	# Auto-detection fallback
	if [ -f "$APP_SOURCE/Gemfile" ]; then
		DETECTED="ruby:latest"
	elif [ -f "$APP_SOURCE/package.json" ]; then
		DETECTED="node:20"
	elif [ -f "$APP_SOURCE/requirements.txt" ]; then
		DETECTED="python:3.11"
	else
		DETECTED="ruby:latest"
	fi

	echo "--- No .base-image found. Auto-detected $DETECTED ---"
	echo "$DETECTED" > "$BASE_IMAGE_FILE"
	export BASE_IMAGE="$DETECTED"
fi

# Create a tag friendly version (e.g., ruby-latest)
export BASE_IMAGE_TAG=$(echo "$BASE_IMAGE" | tr ':' '-')

# Generate a unique ID based on the path (e.g., "my-ruby-app-8a2f")
# This prevents different projects from clobbering each other
if command -v md5 >/dev/null 2>&1; then
	PROJ_HASH=$(echo "$APP_SOURCE" | md5 | cut -c 1-4)
else
	PROJ_HASH=$(echo "$APP_SOURCE" | md5sum | cut -c 1-4)
fi
PROJ_NAME=$(basename "$APP_SOURCE" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
export IMAGE_NAME="$IMAGE_PREFIX-$BASE_IMAGE_TAG"
export CONTAINER_NAME="$IMAGE_NAME-$PROJ_NAME-$PROJ_HASH"

# Export IDs for Docker Compose
export USER_ID=$(id -u)
export GROUP_ID=$(id -g)

# --- COMMANDS ---
clide_stop() {
	if [ "$1" == "-a" ]; then
		echo "--- Stopping ALL clide containers ---"
		docker ps --filter "name=$IMAGE_PREFIX-" -aq | xargs -r docker stop
	elif [ "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Stopping $PROJ_NAME ---"
		docker stop "$CONTAINER_NAME"
	else
		echo "--- No active container for this directory ---"
	fi
}

clide_clean() {
	echo "--- Pruning Docker networks & orphaned volumes ---"
	docker network prune -f
	# Add volume pruning if desired
}

clide_start() {
	echo "Starting Clide PDE"
	# 1. CHECK FOR UPDATES
	# Get the creation timestamp of the local image (if it exists)
	IMAGE_TIME=$(docker image inspect -f '{{.Created}}' "$IMAGE_NAME" 2>/dev/null)

	if [ -n "$IMAGE_TIME" ]; then
		# Convert ISO 8601 timestamp to Unix epoch
		IMAGE_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${IMAGE_TIME%.*}" "+%s" 2>/dev/null || date -d "$IMAGE_TIME" "+%s")

		# Check if Dockerfile or any file in configs/ is newer than the image
		# We use 'find' to get the max mtime of the build context
		LATEST_MOD=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec stat -f "%m" {} + 2>/dev/null | sort -nr | head -n1)

		# Check for md5 (macOS) or md5sum (Linux)
		if command -v md5 >/dev/null 2>&1; then
			FILES_HASH=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec md5 -q {} + | md5 -q)
		else
			FILES_HASH=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec md5sum {} + | md5sum | cut -d' ' -f1)
		fi

		OLD_HASH=$(cat "$PDE_DIR/.build_hash" 2>/dev/null)

		if [ "$FILES_HASH" != "$OLD_HASH" ]; then
			echo "--- Changes detected. Rebuilding PDE image... ---"
			docker compose -f "$PDE_DIR/docker-compose.yml" build && echo "$FILES_HASH" > "$PDE_DIR/.build_hash"
		fi

	else
		echo "--- Image not found. Initial build... ---"
		docker compose -f "$PDE_DIR/docker-compose.yml" build
	fi

	# 2. Ensure the container is running in the background
	if [ ! "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Launching PDE for $PROJ_NAME ---"
		# -d runs it in the background
		COMPOSE_PROJECT_NAME="$CONTAINER_NAME" \
			docker compose -f "$PDE_DIR/docker-compose.yml" up -d --remove-orphans
	fi

	# 3. Always use 'exec' to enter the environment
	# This calls your tmux-start.sh which handles create-or-attach
	docker exec -it $CONTAINER_NAME tmux-start
}

clide_version(){
	echo "CLIDE Version: $CLIDE_VERSION"
}

clide_check() {
	echo "--- CLIDE System Check ---"
	clide_version
	echo "OS: $(uname -s) ($(uname -m))"

	# Check Docker
	if command -v docker >/dev/null 2>&1; then
		echo "Docker: $(docker version --format '{{.Server.Version}}') ✅"
	else
		echo "Docker: NOT FOUND ❌"
	fi

	# Check Docker Compose
	if docker compose version >/dev/null 2>&1; then
		echo "Compose: $(docker compose version --short) ✅"
	else
		echo "Compose: NOT FOUND ❌ (Ensure Docker Compose V2 is installed)"
	fi

	# Check Permissions/Environment
	echo "User ID: $(id -u)"
	# Cross-platform Group Name lookup
	if command -v getent >/dev/null 2>&1; then
	    # Linux way
	    GROUP_NAME=$(getent group $(id -g) | cut -d: -f1)
	else
	    # macOS way
	    GROUP_NAME=$(id -gn)
	fi

	echo "Group ID: $(id -g) ($GROUP_NAME)"

	echo ""
	echo "--- Project Context ---"
	echo "Current Dir: $APP_SOURCE"
	if [ -f "$APP_SOURCE/.base-image" ]; then
		echo ".base-image: $(cat "$APP_SOURCE/.base-image")"
	else
		echo ".base-image: NOT FOUND (Will auto-detect on start)"
	fi
}

clide_usage(){
	echo "Usage: clide {start|stop|clean|check|version}"
	clide_version
}

# --- DISPATCHER ---
case "$1" in
	start)  	clide_start ;;
	stop)   	clide_stop "$2" ;;
	clean)  	clide_clean ;;
	check)		clide_check ;;
	version) 	clide_version ;;
	*)      	clide_usage ; exit 1 ;;
esac
