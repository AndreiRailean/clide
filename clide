#!/bin/bash
CLIDE_VERSION="0.1.0"

IMAGE_PREFIX="clide"

# Get the absolute path of the directory where this script lives
CLIDE_DIR="$(cd "$(dirname "${BASH_SOURCE}")" && pwd)"
CURRENT_DIR="$(pwd)"

# Function to find the project root by looking for .base-image
find_project_root() {
	local dir="$1"
	# Stop if we hit the actual system root or the user's home (to prevent pollution)
	while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
		if [[ -f "$dir/.base-image" ]]; then
			echo "$dir"
			return 0
		fi
		dir="$(dirname "$dir")"
	done
	return 1
}

PROJECT_ROOT=$(find_project_root "$CURRENT_DIR")

BASE_IMAGE_FILE="$PROJECT_ROOT/.base-image"

if [ -f "$BASE_IMAGE_FILE" ]; then
	export BASE_IMAGE=$(cat "$BASE_IMAGE_FILE" | xargs)
else
	export BASE_IMAGE="ruby:latest"
fi

# Create a tag friendly version (e.g., ruby-latest)
export BASE_IMAGE_TAG=$(echo "$BASE_IMAGE" | tr ':' '-')

# Generate a unique ID based on the path (e.g., "my-ruby-app-8a2f")
# This prevents different projects from clobbering each other
if command -v md5 >/dev/null 2>&1; then
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5 | cut -c 1-4)
else
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5sum | cut -c 1-4)
fi
PROJ_NAME=$(basename "$PROJECT_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
export IMAGE_NAME="$IMAGE_PREFIX-$BASE_IMAGE_TAG"
export CONTAINER_NAME="$IMAGE_NAME-$PROJ_NAME-$PROJ_HASH"
export PROJECT_HOSTNAME="clide-$PROJ_NAME-$PROJ_HASH"

# Export IDs for Docker Compose
export USER_ID=$(id -u)
export GROUP_ID=$(id -g)

# --- COMMANDS ---
clide_init() {
	if [ -n "$PROJECT_ROOT" ]; then
		echo "--- Already inside a CLIDE project at $PROJECT_ROOT ---"
		exit 0
	fi

	# Simple auto-detection for the initial file
	if [ -f "Gemfile" ]; then DETECTED="ruby:latest"
	elif [ -f "package.json" ]; then DETECTED="node:20"
	elif [ -f "requirements.txt" ]; then DETECTED="python:3.11"
	else DETECTED="ruby:latest"; fi

	echo "$DETECTED" > "$CURRENT_DIR/.base-image"
	echo "--- Initialised CLIDE project in $CURRENT_DIR (.base-image: $DETECTED) ---"
}

clide_stop() {
	# Global stop of all containers
	if [ "$1" == "-a" ]; then
		echo "--- Stopping ALL clide containers ---"
		docker ps --filter "name=$IMAGE_PREFIX-" -aq | xargs -r docker stop
	fi

	# Scenario 2: Stop by specific name
	if [[ -n "$1" ]]; then
		if [[ "$1" == $IMAGE_PREFIX-* ]]; then
			echo "--- Stopping specific container: $1 ---"
			docker stop "$1"
		else
			echo "‚ùå Error: Invalid container name. Use 'clide list' to find the name."
		fi
		return 0
	fi


	# Check if we are actually in a project for a local stop
	if [ -z "$PROJECT_ROOT" ]; then
		echo "‚ùå Error: Not inside a CLIDE project."
		echo "Navigate to a project directory or use 'clide stop -a' to stop everything."
		exit 1
	fi

	if [ "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Stopping $PROJ_NAME ---"
		docker stop "$CONTAINER_NAME"
	else
		echo "--- No active container for this directory ---"
	fi
}

clide_clean() {
	echo "--- Pruning Docker networks & orphaned volumes ---"
	docker network prune -f
	# Add volume pruning if desired
}

check_for_updates() {
	# Only check once a day to stay fast
	LAST_CHECK_FILE="$CLIDE_DIR/.last_update_check"
	CURRENT_TIME=$(date +%s)
	# 216000 seconds = 6 hours
	SIX_HOURS=21600

	# If we checked recently, skip
	if [ -f "$LAST_CHECK_FILE" ]; then
		LAST_CHECK=$(cat "$LAST_CHECK_FILE")
		if (( CURRENT_TIME - LAST_CHECK < SIX_HOURS)); then return; fi
	fi

	echo "Checking clide for updates"

	git -C "$CLIDE_DIR" fetch origin main -q 2>/dev/null
	LOCAL_HASH=$(git -C "$CLIDE_DIR" rev-parse HEAD)
	REMOTE_HASH=$(git -C "$CLIDE_DIR" rev-parse origin/main)

	if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
		export CLIDE_UPDATE_PENDING="true"
	else
		export CLIDE_UPDATE_PENDING="false"
	fi

	echo "$CURRENT_TIME" > "$LAST_CHECK_FILE"
}

show_update_notice() {
	if [ "$CLIDE_UPDATE_PENDING" = "true" ]; then
		echo -e "\n\033[1;33m[CLIDE] üì¢ Update available! Run 'clide update' on host.\033[0m\n"
	fi
}

clide_start() {
	echo "Starting CLIDE"
	if [ -z "$PROJECT_ROOT" ]; then
		echo "‚ùå Error: Not a CLIDE project (no .base-image found)."
		echo "Run 'clide init' to initialise this folder, or 'clide start' from a subfolder of an existing project."
		exit 1
	fi

	# Now use PROJECT_ROOT instead of PWD for all logic
	export APP_SOURCE="$PROJECT_ROOT"

	# 1. CHECK FOR UPDATES
	# Get the creation timestamp of the local image (if it exists)
	IMAGE_TIME=$(docker image inspect -f '{{.Created}}' "$IMAGE_NAME" 2>/dev/null)

	if [ -n "$IMAGE_TIME" ]; then
		# Convert ISO 8601 timestamp to Unix epoch
		IMAGE_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${IMAGE_TIME%.*}" "+%s" 2>/dev/null || date -d "$IMAGE_TIME" "+%s")

		# Check if Dockerfile or any file in configs/ is newer than the image
		# We use 'find' to get the max mtime of the build context
		LATEST_MOD=$(find "$CLIDE_DIR/Dockerfile" "$CLIDE_DIR/configs" -type f -exec stat -f "%m" {} + 2>/dev/null | sort -nr | head -n1)

		# Check for md5 (macOS) or md5sum (Linux)
		if command -v md5 >/dev/null 2>&1; then
			FILES_HASH=$(find "$CLIDE_DIR/Dockerfile" "$CLIDE_DIR/configs" -type f -exec md5 -q {} + | md5 -q)
		else
			FILES_HASH=$(find "$CLIDE_DIR/Dockerfile" "$CLIDE_DIR/configs" -type f -exec md5sum {} + | md5sum | cut -d' ' -f1)
		fi

		OLD_HASH=$(cat "$CLIDE_DIR/.build_hash" 2>/dev/null)

		if [ "$FILES_HASH" != "$OLD_HASH" ]; then
			echo "--- Changes detected. Rebuilding PDE image... ---"
			docker compose -f "$CLIDE_DIR/docker-compose.yml" build && echo "$FILES_HASH" > "$CLIDE_DIR/.build_hash"
		fi

	else
		echo "--- Image not found. Initial build... ---"
		docker compose -f "$CLIDE_DIR/docker-compose.yml" build
	fi

	# 2. Ensure the container is running in the background
	if [ ! "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Launching PDE for $PROJ_NAME ---"
		# -d runs it in the background
		COMPOSE_PROJECT_NAME="$CONTAINER_NAME" \
			docker compose -f "$CLIDE_DIR/docker-compose.yml" up -d --remove-orphans
	fi

	# 3. Always use 'exec' to enter the environment
	# This calls your tmux-start.sh which handles create-or-attach
	docker exec -it $CONTAINER_NAME tmux-start
}

clide_version(){
	echo "CLIDE Version: $CLIDE_VERSION"
}

clide_check() {
	echo "--- CLIDE System Check ---"
	clide_version
	echo "OS: $(uname -s) ($(uname -m))"

	# Check Docker
	if command -v docker >/dev/null 2>&1; then
		echo "Docker: $(docker version --format '{{.Server.Version}}') ‚úÖ"
	else
		echo "Docker: NOT FOUND ‚ùå"
	fi

	# Check Docker Compose
	if docker compose version >/dev/null 2>&1; then
		echo "Compose: $(docker compose version --short) ‚úÖ"
	else
		echo "Compose: NOT FOUND ‚ùå (Ensure Docker Compose V2 is installed)"
	fi

	# Check Permissions/Environment
	echo "User ID: $(id -u)"
	# Cross-platform Group Name lookup
	if command -v getent >/dev/null 2>&1; then
		# Linux way
		GROUP_NAME=$(getent group $(id -g) | cut -d: -f1)
	else
		# macOS way
		GROUP_NAME=$(id -gn)
	fi

	echo "Group ID: $(id -g) ($GROUP_NAME)"

	echo ""
	echo "--- Project Context ---"
	echo "Current Project: $PROJECT_ROOT"
	if [ -f "$PROJECT_ROOT/.base-image" ]; then
		echo ".base-image: $(cat "$PROJECT_ROOT/.base-image")"
	else
		echo ".base-image: NOT FOUND"
	fi
}

clide_help() {
    echo "CLIDE - Containerised Lightweight IDE (v$CLIDE_VERSION)"
    echo ""
    echo "Usage: clide <command> [options]"
    echo ""
    echo "Commands:"
    echo "  init        Initialise a project (creates .base-image)"
    echo "  start       Launch or re-attach to the IDE for this project"
    echo "  stop        Stop the container for the current directory"
    echo "  stop -a     Stop ALL active CLIDE containers"
    echo "  stop [name] Stop a specific container by name"
    echo "  list        List all currently running CLIDE environments"
    echo "  check       Run system diagnostics and check project context"
    echo "  update      Pull the latest CLIDE code and rebuild images"
    echo "  clean       Prune orphaned Docker networks and volumes"
    echo "  version     Show the current CLIDE version"
    echo ""
    echo "Example:"
    echo "  clide start"
}

clide_list(){
	echo "--- Active CLIDE Environments ---"
	# Format: Container Name | Base Image | Status
	docker ps --filter "name=$IMAGE_PREFIX-" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
}

clide_update() {
	# Silently pull from GitHub
	git -C "$CLIDE_DIR" pull origin main

	# Check how many commits the local branch is behind
	# @{u} refers to the upstream branch (origin/main)
	BEHIND_COUNT=$(git -C "$IDE_DIR" rev-list --count HEAD..@{u} 2>/dev/null)

	if [[ "$BEHIND_COUNT" -gt 0 ]]; then
		echo "--- Updating CLIDE from GitHub ($BEHIND_COUNT new commits) ---"
		git -C "$IDE_DIR" pull origin main -q
		echo "--- Update complete. Image will rebuild on next start ---"

		LAST_CHECK_FILE="$CLIDE_DIR/.last_update_check"
		CURRENT_TIME=$(date +%s)
		echo "$CURRENT_TIME" > "$LAST_CHECK_FILE"
	else
		# Optional: You can remove this echo entirely if you want zero output
		echo "--- CLIDE is already up to date ---"
	fi
}


check_for_updates

# --- DISPATCHER ---
case "$1" in
	init)		
		clide_init 
		;;
	start)  	
		clide_start 
		show_update_notice
		;;
	stop)   	
		show_update_notice
		clide_stop "$2" 
		;;
	clean)  	
		show_update_notice
		clide_clean 
		;;
	check)		
		show_update_notice
		clide_check 
		;;
	list)		
		show_update_notice
		clide_list 
		;;
	version) 
		show_update_notice
		clide_version 
		;;
	update)
		clide_update
		;;
	*)      	
		show_update_notice	
		clide_help; exit 1 
		;;
esac
