#!/bin/bash
CLIDE_VERSION="0.1.0"

IMAGE_PREFIX="clide"

# Get the absolute path of the directory where this script lives
PDE_DIR="$(cd "$(dirname "${BASH_SOURCE}")" && pwd)"
CURRENT_DIR="$(pwd)"

# Function to find the project root by looking for .base-image
find_project_root() {
	local dir="$1"
	# Stop if we hit the actual system root or the user's home (to prevent pollution)
	while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
		if [[ -f "$dir/.base-image" ]]; then
			echo "$dir"
			return 0
		fi
		dir="$(dirname "$dir")"
	done
	return 1
}

PROJECT_ROOT=$(find_project_root "$CURRENT_DIR")

BASE_IMAGE_FILE="$PROJECT_ROOT/.base-image"

if [ -f "$BASE_IMAGE_FILE" ]; then
	export BASE_IMAGE=$(cat "$BASE_IMAGE_FILE" | xargs)
else
	export BASE_IMAGE="ruby:latest"
fi

# Create a tag friendly version (e.g., ruby-latest)
export BASE_IMAGE_TAG=$(echo "$BASE_IMAGE" | tr ':' '-')

# Generate a unique ID based on the path (e.g., "my-ruby-app-8a2f")
# This prevents different projects from clobbering each other
if command -v md5 >/dev/null 2>&1; then
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5 | cut -c 1-4)
else
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5sum | cut -c 1-4)
fi
PROJ_NAME=$(basename "$PROJECT_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
export IMAGE_NAME="$IMAGE_PREFIX-$BASE_IMAGE_TAG"
export CONTAINER_NAME="$IMAGE_NAME-$PROJ_NAME-$PROJ_HASH"

# Export IDs for Docker Compose
export USER_ID=$(id -u)
export GROUP_ID=$(id -g)

# --- COMMANDS ---
clide_init() {
	if [ -n "$PROJECT_ROOT" ]; then
		echo "--- Already inside a CLIDE project at $PROJECT_ROOT ---"
		exit 0
	fi

	# Simple auto-detection for the initial file
	if [ -f "Gemfile" ]; then DETECTED="ruby:latest"
	elif [ -f "package.json" ]; then DETECTED="node:20"
	elif [ -f "requirements.txt" ]; then DETECTED="python:3.11"
	else DETECTED="ruby:latest"; fi

	echo "$DETECTED" > "$CURRENT_DIR/.base-image"
	echo "--- Initialised CLIDE project in $CURRENT_DIR (.base-image: $DETECTED) ---"
}

clide_stop() {
	# Global stop of all containers
	if [ "$1" == "-a" ]; then
		echo "--- Stopping ALL clide containers ---"
		docker ps --filter "name=$IMAGE_PREFIX-" -aq | xargs -r docker stop
	fi

	# Scenario 2: Stop by specific name
	if [[ -n "$1" ]]; then
		if [[ "$1" == $IMAGE_PREFIX-* ]]; then
			echo "--- Stopping specific container: $1 ---"
			docker stop "$1"
		else
			echo "❌ Error: Invalid container name. Use 'clide list' to find the name."
		fi
		return 0
	fi


	# Check if we are actually in a project for a local stop
	if [ -z "$PROJECT_ROOT" ]; then
		echo "❌ Error: Not inside a CLIDE project."
		echo "Navigate to a project directory or use 'clide stop -a' to stop everything."
		exit 1
	fi

	if [ "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Stopping $PROJ_NAME ---"
		docker stop "$CONTAINER_NAME"
	else
		echo "--- No active container for this directory ---"
	fi
}

clide_clean() {
	echo "--- Pruning Docker networks & orphaned volumes ---"
	docker network prune -f
	# Add volume pruning if desired
}

clide_start() {
	echo "Starting CLIDE"
	if [ -z "$PROJECT_ROOT" ]; then
		echo "❌ Error: Not a CLIDE project (no .base-image found)."
		echo "Run 'clide init' to initialise this folder, or 'clide start' from a subfolder of an existing project."
		exit 1
	fi

	# Now use PROJECT_ROOT instead of PWD for all logic
	export APP_SOURCE="$PROJECT_ROOT"

	# 1. CHECK FOR UPDATES
	# Get the creation timestamp of the local image (if it exists)
	IMAGE_TIME=$(docker image inspect -f '{{.Created}}' "$IMAGE_NAME" 2>/dev/null)

	if [ -n "$IMAGE_TIME" ]; then
		# Convert ISO 8601 timestamp to Unix epoch
		IMAGE_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${IMAGE_TIME%.*}" "+%s" 2>/dev/null || date -d "$IMAGE_TIME" "+%s")

		# Check if Dockerfile or any file in configs/ is newer than the image
		# We use 'find' to get the max mtime of the build context
		LATEST_MOD=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec stat -f "%m" {} + 2>/dev/null | sort -nr | head -n1)

		# Check for md5 (macOS) or md5sum (Linux)
		if command -v md5 >/dev/null 2>&1; then
			FILES_HASH=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec md5 -q {} + | md5 -q)
		else
			FILES_HASH=$(find "$PDE_DIR/Dockerfile" "$PDE_DIR/configs" -type f -exec md5sum {} + | md5sum | cut -d' ' -f1)
		fi

		OLD_HASH=$(cat "$PDE_DIR/.build_hash" 2>/dev/null)

		if [ "$FILES_HASH" != "$OLD_HASH" ]; then
			echo "--- Changes detected. Rebuilding PDE image... ---"
			docker compose -f "$PDE_DIR/docker-compose.yml" build && echo "$FILES_HASH" > "$PDE_DIR/.build_hash"
		fi

	else
		echo "--- Image not found. Initial build... ---"
		docker compose -f "$PDE_DIR/docker-compose.yml" build
	fi

	# 2. Ensure the container is running in the background
	if [ ! "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
		echo "--- Launching PDE for $PROJ_NAME ---"
		# -d runs it in the background
		COMPOSE_PROJECT_NAME="$CONTAINER_NAME" \
			docker compose -f "$PDE_DIR/docker-compose.yml" up -d --remove-orphans
	fi

	# 3. Always use 'exec' to enter the environment
	# This calls your tmux-start.sh which handles create-or-attach
	docker exec -it $CONTAINER_NAME tmux-start
}

clide_version(){
	echo "CLIDE Version: $CLIDE_VERSION"
}

clide_check() {
	echo "--- CLIDE System Check ---"
	clide_version
	echo "OS: $(uname -s) ($(uname -m))"

	# Check Docker
	if command -v docker >/dev/null 2>&1; then
		echo "Docker: $(docker version --format '{{.Server.Version}}') ✅"
	else
		echo "Docker: NOT FOUND ❌"
	fi

	# Check Docker Compose
	if docker compose version >/dev/null 2>&1; then
		echo "Compose: $(docker compose version --short) ✅"
	else
		echo "Compose: NOT FOUND ❌ (Ensure Docker Compose V2 is installed)"
	fi

	# Check Permissions/Environment
	echo "User ID: $(id -u)"
	# Cross-platform Group Name lookup
	if command -v getent >/dev/null 2>&1; then
		# Linux way
		GROUP_NAME=$(getent group $(id -g) | cut -d: -f1)
	else
		# macOS way
		GROUP_NAME=$(id -gn)
	fi

	echo "Group ID: $(id -g) ($GROUP_NAME)"

	echo ""
	echo "--- Project Context ---"
	echo "Current Project: $PROJECT_ROOT"
	if [ -f "$PROJECT_ROOT/.base-image" ]; then
		echo ".base-image: $(cat "$PROJECT_ROOT/.base-image")"
	else
		echo ".base-image: NOT FOUND"
	fi
}

clide_usage(){
	echo "Usage: clide {init|start|stop|clean|check|version}"
	clide_version
}

clide_list(){
	echo "--- Active CLIDE Environments ---"
	# Format: Container Name | Base Image | Status
	docker ps --filter "name=$IMAGE_PREFIX-" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
}

# --- DISPATCHER ---
case "$1" in
	init)		clide_init ;;
	start)  	clide_start ;;
	stop)   	clide_stop "$2" ;;
	clean)  	clide_clean ;;
	check)		clide_check ;;
	list)		clide_list ;;
	version) 	clide_version ;;
	*)      	clide_usage ; exit 1 ;;
esac
