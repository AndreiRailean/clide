#!/usr/bin/env bash
CLIDE_VERSION="0.1.0"

PROJECT_NAME="clide"

# Get the absolute path of the directory where this script lives
CLIDE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CURRENT_DIR="$(pwd)"

if [[ "$CLIDE_DIR/" == *"/devclide/"* ]]; then
	export EXECUTABLE="devclide"
	export CLIDE_MODE="DEVELOPMENT"
	export IMAGE_PREFIX="$PROJECT_NAME-dev"
else
	export EXECUTABLE="clide"
	export CLIDE_MODE="PRODUCTION"
	export IMAGE_PREFIX="$PROJECT_NAME"
fi

# Function to find the project root by looking for .clide_state or .base-image
find_project_root() {
	local dir="$1"
	# Stop if we hit the actual system root or the user's home (to prevent pollution)
	while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
		if [[ -f "$dir/.base-image" ]] || [[ -d "$dir/.clide_state" ]]; then
			echo "$dir"
			return 0
		fi
		dir="$(dirname "$dir")"
	done
	return 1
}

PROJECT_ROOT=$(find_project_root "$CURRENT_DIR")
export APP_SOURCE="$PROJECT_ROOT"

# Perform Migration if necessary
if [ -n "$PROJECT_ROOT" ]; then
	LEGACY_IMAGE="$PROJECT_ROOT/.base-image"
	STATE_DIR="$PROJECT_ROOT/.clide_state"

	if [ -f "$LEGACY_IMAGE" ]; then
		echo "--- Migrating .base-image to $STATE_DIR ---"
		mkdir -p "$STATE_DIR"
		mv "$LEGACY_IMAGE" "$STATE_DIR/base_image"

	# migrate the build hash
	if [ -f "$PROJECT_ROOT/.build_hash" ]; then
		mv "$PROJECT_ROOT/.build_hash" "$STATE_DIR/build_hash"
	fi
	fi
fi

if [ -d "$PROJECT_ROOT/.git" ] && ! grep -q ".clide_state" "$PROJECT_ROOT/.gitignore" 2>/dev/null; then
	echo "üí° Note: Don't forget to add .clide_state/ to your .gitignore"
fi

STATE_DIR="$APP_SOURCE/.clide_state"
LOCAL_HASH_FILE="$STATE_DIR/build_hash"
BASE_IMAGE_FILE="$STATE_DIR/base_image"

if [ -f "$BASE_IMAGE_FILE" ]; then
	BASE_IMAGE=$(cat "$BASE_IMAGE_FILE" | xargs)
	export BASE_IMAGE
else
	export BASE_IMAGE="ruby:4"
fi

# Create a tag friendly version (e.g., ruby-latest)
BASE_IMAGE_TAG=$(echo "$BASE_IMAGE" | tr ':' '-')
export BASE_IMAGE_TAG

# Generate a unique ID based on the path (e.g., "my-ruby-app-8a2f")
# This prevents different projects from clobbering each other
if command -v md5 >/dev/null 2>&1; then
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5 | cut -c 1-4)
else
	PROJ_HASH=$(echo "$PROJECT_ROOT" | md5sum | cut -c 1-4)
fi
PROJ_NAME=$(basename "$PROJECT_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
export IMAGE_NAME="$IMAGE_PREFIX-$BASE_IMAGE_TAG"
export CONTAINER_NAME="$IMAGE_NAME-$PROJ_NAME-$PROJ_HASH"
export PROJECT_HOSTNAME="$PROJECT_NAME-$PROJ_NAME-$PROJ_HASH"

# Export IDs for Docker Compose
USER_ID=$(id -u); export USER_ID
GROUP_ID=$(id -g); export GROUP_ID

# Detects the appropriate Docker image based on files in a directory
detect_base_image() {
	local target_dir="$1"

	if [ -f "$target_dir/Gemfile" ]; then
		echo "ruby:4"
	elif [ -f "$target_dir/package.json" ]; then
		echo "node:22"
	elif [ -f "$target_dir/requirements.txt" ]; then
		echo "python:3.11"
	else
		echo "ruby:4"
	fi
}

# --- COMMANDS ---
clide_init() {
	if [ -n "$PROJECT_ROOT" ]; then
		echo "‚úÖ Already a CLIDE project at $PROJECT_ROOT"
		exit 0
	fi

	mkdir -p "$CURRENT_DIR/.clide_state"

	local detected
	detected=$(detect_base_image "$CURRENT_DIR")

	echo "$detected" > "$CURRENT_DIR/.clide_state/base_image"
	echo "üöÄ CLIDE project initialised in $CURRENT_DIR with $detected image"

	local gitignore="$CURRENT_DIR/.gitignore"
	if [ -d "$CURRENT_DIR/.git" ] || [ -f "$gitignore" ]; then
		if [ ! -f "$gitignore" ] || ! grep -q ".clide_state" "$gitignore"; then
			echo ""
			echo "üí° Tip: Add .clide_state to your .gitignore to keep your repo clean:"
			echo "   echo \".clide_state/\" >> .gitignore"
		fi
	fi
}

clide_clean() {
	echo "--- Cleaning up old containers ---"
	docker ps -a --filter "name=$IMAGE_PREFIX-" --filter status=exited -q | xargs docker rm
}

clide_stop() {
	# Global stop of all containers
	if [ "$1" == "-a" ]; then
		local running_ids
		running_ids=$(docker ps --filter "name=$IMAGE_PREFIX-" -q)

		if [[ -z "$running_ids" ]]; then
			echo "‚úÖ No active CLIDE containers to stop."
		else
			echo "--- Stopping ALL clide containers ---"
			echo "$running_ids" | xargs -r docker stop
			echo "$running_ids" | xargs -r docker rm
			docker network prune -f > /dev/null
		fi
		return 0
	fi

	# Scenario 2: Stop by specific name
	if [[ -n "$1" ]]; then
		if [[ "$1" == $IMAGE_PREFIX-* ]]; then
			found_container=$(docker ps -q -f name="$1")
			if [ "$found_container" ]; then
				echo "--- Stopping container: $1 ---"
				docker stop "$1"
			else
				echo "‚ùå Error: Container '$1' is not running."
			fi
		else
			echo "‚ùå Error: Invalid container name. Use '$EXECUTABLE list' to find the name."
		fi
		return 0
	fi


	# Check if we are actually in a project for a local stop
	if [ -z "$PROJECT_ROOT" ]; then
		echo "‚ùå Error: Not inside a CLIDE project."
		echo "Navigate to a project directory or use '$EXECUTABLE stop -a' to stop everything."
		exit 1
	fi

	if [ "$(docker ps -q -f name="$CONTAINER_NAME")" ]; then
		echo "--- Stopping $PROJ_NAME ---"
		docker compose -f "$CLIDE_DIR/docker-compose.yml" -p "$CONTAINER_NAME" down
	else
		echo "--- No active container for this directory ---"
	fi
}

check_for_updates() {
	# Only check once a day to stay fast
	LAST_CHECK_FILE="$CLIDE_DIR/.last_update_check"
	CURRENT_TIME=$(date +%s)
	# 216000 seconds = 6 hours
	SIX_HOURS=21600

	# If we checked recently, skip
	if [ -f "$LAST_CHECK_FILE" ]; then
		LAST_CHECK=$(cat "$LAST_CHECK_FILE")
		if (( CURRENT_TIME - LAST_CHECK < SIX_HOURS)); then return; fi
	fi

	echo "Checking clide for updates"

	git -C "$CLIDE_DIR" fetch origin main -q 2>/dev/null
	LOCAL_HASH=$(git -C "$CLIDE_DIR" rev-parse HEAD)
	REMOTE_HASH=$(git -C "$CLIDE_DIR" rev-parse origin/main)

	if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
		export CLIDE_UPDATE_PENDING="true"
	else
		export CLIDE_UPDATE_PENDING="false"
	fi

	echo "$CURRENT_TIME" > "$LAST_CHECK_FILE"
}

show_update_notice() {
	if [ "$CLIDE_UPDATE_PENDING" = "true" ]; then
		echo -e "\n\033[1;33m[CLIDE] üì¢ Update available! Run '$EXECUTABLE update' on host.\033[0m\n"
	fi
}

clide_start() {
	echo "Starting CLIDE"
	if [ -z "$PROJECT_ROOT" ]; then
		echo "‚ùå Error: Not a CLIDE project."
		echo "Run '$EXECUTABLE init' to initialise this folder, or '$EXECUTABLE start' from a subfolder of an existing project."
		exit 1
	fi

	# If the folder exists but the specific metadata is missing
	if [ ! -f "$BASE_IMAGE_FILE" ]; then
		echo "‚ùå Error: Your CLIDE project requires repair."
		echo "üëâ Run '$EXECUTABLE doctor' to repair the project metadata."
		exit 1
	fi

	# 1. CHECK FOR UPDATES
	# Get the creation timestamp of the local image (if it exists)
	BUILD_CONTEXT_VARS="BASE_IMAGE=$BASE_IMAGE;USER_ID=$USER_ID;GROUP_ID=$GROUP_ID"

	# Check for md5 (macOS) or md5sum (Linux)
	if command -v md5 >/dev/null 2>&1; then
		BUILD_HASH=$(find "$CLIDE_DIR/Dockerfile" "$CLIDE_DIR/configs" -type f -exec md5 -q {} +; echo "$BUILD_CONTEXT_VARS" | md5 -q)
	else
		BUILD_HASH=$(find "$CLIDE_DIR/Dockerfile" "$CLIDE_DIR/configs" -type f -exec md5sum {} +; echo "$BUILD_CONTEXT_VARS" | md5sum | cut -d' ' -f1)
	fi

	OLD_HASH=$(cat "$LOCAL_HASH_FILE" 2>/dev/null)

	if [ -z "$OLD_HASH" ]; then
		echo "--- Image not found. Initial build... ---"
		docker compose -f "$CLIDE_DIR/docker-compose.yml" build && echo "$BUILD_HASH" > "$LOCAL_HASH_FILE"
	elif [ "$BUILD_HASH" != "$OLD_HASH" ]; then
		echo "--- Changes detected. Rebuilding PDE image... ---"
		docker compose -f "$CLIDE_DIR/docker-compose.yml" build && echo "$BUILD_HASH" > "$LOCAL_HASH_FILE"
	fi


	# 2. Ensure the container is running in the background
	if [ ! "$(docker ps -q -f name="$CONTAINER_NAME")" ]; then
		echo "--- Launching PDE for $PROJ_NAME ---"
		# -d runs it in the background
		COMPOSE_PROJECT_NAME="$CONTAINER_NAME" \
			docker compose -f "$CLIDE_DIR/docker-compose.yml" -p "$CONTAINER_NAME" up -d --remove-orphans
	fi

	# 3. Always use 'exec' to enter the environment
	# This calls your tmux-start.sh which handles create-or-attach
	docker exec -it "$CONTAINER_NAME" tmux-start
}

clide_version(){
	echo "CLIDE Version: $CLIDE_VERSION"
	if [ "$CLIDE_MODE" == "DEVELOPMENT" ] ; then
		echo "Development Mode"
	fi
}

clide_check() {
	echo "--- CLIDE System Check ---"
	clide_version
	echo "OS: $(uname -s) ($(uname -m))"

	# Check Docker
	if command -v docker >/dev/null 2>&1; then
		echo "Docker: $(docker version --format '{{.Server.Version}}') ‚úÖ"
	else
		echo "Docker: NOT FOUND ‚ùå"
	fi

	# Check Docker Compose
	if docker compose version >/dev/null 2>&1; then
		echo "Compose: $(docker compose version --short) ‚úÖ"
	else
		echo "Compose: NOT FOUND ‚ùå (Ensure Docker Compose V2 is installed)"
	fi

	# Check Docker Context
	if command -v docker >/dev/null 2>&1; then
		CURRENT_CONTEXT=$(docker context show)
		echo "Docker Context: $CURRENT_CONTEXT ‚úÖ"
	fi

	# Check Permissions/Environment
	echo "User ID: $(id -u)"
	# Cross-platform Group Name lookup
	if command -v getent >/dev/null 2>&1; then
		# Linux way
		GROUP_NAME=$(getent group "$(id -g)" | cut -d: -f1)
	else
		# macOS way
		GROUP_NAME=$(id -gn)
	fi

	echo "Group ID: $(id -g) ($GROUP_NAME)"

	echo ""
	echo "--- Project Context ---"
	echo "Current Project: $PROJECT_ROOT"
	if [ -f "$BASE_IMAGE_FILE" ]; then
		echo "base_image: $(cat "$BASE_IMAGE_FILE")"
	else
		echo "base_image: NOT FOUND"
	fi
}

clide_doctor() {
	if [ ! -d "$STATE_DIR" ]; then
		echo "‚ùå Nothing to doctor. Not a CLIDE project."
		echo "If you want to start a new project, run 'clide init'."
		exit 1
	fi

	echo "ü©∫ CLIDE Doctor: Repairing broken state in $PROJECT_ROOT..."

	# Repair base_image if missing
	if [ ! -f "$BASE_IMAGE_FILE" ]; then
		local detected
		detected=$(detect_base_image "$PROJECT_ROOT")
		# ... auto-detection logic ...
		echo "$detected" > "$BASE_IMAGE_FILE"
		echo "üî® Repaired missing image: $detected."
	fi

	# Repair build_hash if missing (forces a rebuild on next start)
	if [ ! -f "$LOCAL_HASH_FILE" ]; then
		echo "0" > "$LOCAL_HASH_FILE"
		echo "üî® Reset build_hash to force a fresh build."
	fi

	echo "‚ú® Repair complete."
}


clide_help() {
	echo "CLIDE---HELP"
	echo "CLIDE - Containerised Lightweight IDE (v$CLIDE_VERSION)"
	echo ""
	echo "Usage: clide <command> [options]"
	echo ""
	echo "Commands:"
	echo "  init        Initialise a project"
	echo "  start       Launch or re-attach to the IDE for this project"
	echo "  stop        Stop the container for the current directory"
	echo "  stop -a     Stop ALL active CLIDE containers"
	echo "  stop [name] Stop a specific container by name"
	echo "  list        List all currently running CLIDE environments"
	echo "  check       Run system diagnostics and check project context"
	echo "  doctor      Repair a broken clide config inside a project"
	echo "  update      Pull the latest CLIDE code and rebuild images"
	echo "  clean       Prune orphaned Docker networks and volumes"
	echo "  completions Initialise shell autocompletion with auto-detected shell"
	echo "  completions [shell]  Initialise shell autocompletion with supplied shell (zsh, bash, or fish)"
	echo "	uninstall   Remove clide from your system (doesn't touch any project folders)"
	echo "  version     Show the current CLIDE version"
	echo ""
	echo "Example:"
	echo "  clide start"
}

clide_list(){
	# If called with --raw, just return names for completion scripts
	if [[ "$1" == "--raw" ]]; then
		docker ps --filter "name=$IMAGE_PREFIX-" --format "{{.Names}}"
		return 0
	fi

	echo "--- Active CLIDE Environments ---"
	# Format: Container Name | Base Image | Status
	docker ps --filter "name=$IMAGE_PREFIX-" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
}

clide_update() {
	# Silently pull from GitHub
	git -C "$CLIDE_DIR" pull origin main

	# Check how many commits the local branch is behind
	# @{u} refers to the upstream branch (origin/main)
	BEHIND_COUNT=$(git -C "$CLIDE_DIR" rev-list --count "HEAD..@{u}" 2>/dev/null)

	if [[ "$BEHIND_COUNT" -gt 0 ]]; then
		echo "--- Updating CLIDE from GitHub ($BEHIND_COUNT new commits) ---"
		git -C "$CLIDE_DIR" pull origin main -q
		echo "--- Update complete. Image will rebuild on next start ---"

		LAST_CHECK_FILE="$CLIDE_DIR/.last_update_check"
		CURRENT_TIME=$(date +%s)
		echo "$CURRENT_TIME" > "$LAST_CHECK_FILE"
	else
		# Optional: You can remove this echo entirely if you want zero output
		echo "--- CLIDE is already up to date ---"
	fi
}

clide_completions() {
	# Detect shell from argument, or fall back to $SHELL environment variable
	local shell_type="${1:-$(basename "$SHELL")}"

	case "$shell_type" in
		zsh)
			echo "autoload -Uz +X compinit && compinit"
			echo "autoload -Uz +X bashcompinit && bashcompinit"
			echo "source \"$CLIDE_DIR/completions/clide.bash\""
			;;
		bash)
			echo "source \"$CLIDE_DIR/completions/clide.bash\""
			;;
		*)
			echo "# clide: completions not available for shell: $shell_type" >&2
			return 1
			;;
	esac
}

clide_debug() {
	echo "--- CLIDE Debug Info ---"
	echo "Mode:                  $CLIDE_MODE"
	echo "Script Path (IDE_DIR): $CLIDE_DIR"
	echo "Current Dir (PWD):     $(pwd)"
	echo "Project Root:          ${PROJECT_ROOT:-NOT SET}"
	echo "App Source:            $APP_SOURCE"
	echo ""
	echo "--- Docker Variables ---"
	echo "Container Name:        $CONTAINER_NAME"
	echo "Image Name:            $IMAGE_NAME"
	echo "Base Image:            $BASE_IMAGE"
	echo ""
	echo "--- User Variables ---"
	echo "User ID:               $USER_ID"
	echo "Group ID:              $GROUP_ID"
}

clide_uninstall() {
	echo -e "\033[1;31m‚ö†Ô∏è  WARNING: This will remove CLIDE and all its configurations.\033[0m"
	read -p "Are you sure you want to proceed? (y/n) " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Yy]$ ]]; then
		echo "Uninstall cancelled."
		exit 0
	fi

	# 1. Stop all active containers
	clide_stop "-a"

	# 2. Remove the shell block
	case "$SHELL" in
		*/zsh)  CONF_FILE="$HOME/.zshrc" ;;
		*/bash) CONF_FILE="$HOME/.bashrc" ;;
		*)      CONF_FILE="$HOME/.profile" ;;
	esac

	if [ -f "$CONF_FILE" ]; then
		echo "üìù Removing config block from $CONF_FILE..."
		if [[ "$(uname)" == "Darwin" ]]; then
			sed -i '' "/# >>> clide initialize >>>/,/# <<< clide initialize <<</d" "$CONF_FILE"
		else
			sed -i "/# >>> clide initialize >>>/,/# <<< clide initialize <<</d" "$CONF_FILE"
		fi
	fi

	# 3. Prompt for directory deletion
	echo ""
	read -p "Do you want to delete the source directory at $CLIDE_DIR? (y/n) " -n 1 -r
	echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		echo "üìÇ Deleting CLIDE source files..."
		# We use a subshell to delete the directory after a 1-second delay 
		# to allow the current script to finish execution and exit cleanly.
		(sleep 1 && rm -rf "$CLIDE_DIR") &
		echo "‚ú® CLIDE has been uninstalled. Please restart your terminal."
	else
		echo "‚úÖ Config removed, but source files kept at: $CLIDE_DIR"
		echo "   To remove manually later: rm -rf $CLIDE_DIR"
	fi

	echo "Thank you for using CLIDE"

	exit 0
}

check_for_updates

# --- DISPATCHER ---
case "$1" in
	init)		
		clide_init 
		;;
	start)  	
		clide_start 
		show_update_notice
		;;
	stop)   	
		show_update_notice
		clide_stop "$2" 
		clide_clean
		;;
	clean)  	
		show_update_notice
		clide_clean 
		;;
	check)		
		show_update_notice
		clide_check 
		;;
	list)		
		show_update_notice
		clide_list "$2"
		;;
	version) 
		show_update_notice
		clide_version 
		;;
	update)
		clide_update
		;;
	shell-init)
		# TODO: remove shell-init in future version
		clide_completions "$2"
		;;
	completions)
		clide_completions "$2"
		;;
	debug)
		clide_debug
		;;
	doctor)
		clide_doctor
		;;
	uninstall)
		clide_uninstall
		;;
	*)      	
		show_update_notice	
		clide_help; exit 1 
		;;
esac
